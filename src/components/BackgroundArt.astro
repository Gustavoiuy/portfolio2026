---
// src/components/ui/NeuralBackground.astro
---

<div
  id="neural-container"
  class="fixed inset-0 z-[-1] pointer-events-none bg-neutral-950"
  style="mask-image: radial-gradient(circle at center, transparent 0%, black 100%); -webkit-mask-image: radial-gradient(circle at center, transparent 0%, black 100%);"
  aria-hidden="true"
>
  <canvas id="neural-canvas" class="block w-full h-full"></canvas>
</div>

<script>
  // Configuración "Hot-swappable" para ajustar el diseño visual
  const CONFIG = {
    particleCount: 60, // Cantidad de nodos (se ajusta auto según pantalla)
    connectionRadius: 140, // Distancia máxima para conectar nodos
    mouseRadius: 180, // Radio de interacción con el mouse
    baseColor: "rgba(150, 150, 150, 0.25)", // Color de nodos pasivos
    accentColor: "rgba(56, 189, 248, 0.6)", // Color de conexión activa (Cyan/Azul eléctrico)
    speed: 0.6, // Velocidad de movimiento flotante
  };

  class NeuralNetwork {
    canvas: HTMLCanvasElement;
    ctx!: CanvasRenderingContext2D;
    width!: number;
    height!: number;
    particles!: Particle[];
    mouse!: { x: number; y: number };
    animationId!: number;

    constructor() {
      this.canvas = document.getElementById(
        "neural-canvas"
      ) as HTMLCanvasElement;
      if (!this.canvas) return;

      this.ctx = this.canvas.getContext("2d")!;
      this.width = 0;
      this.height = 0;
      this.particles = [];
      this.mouse = { x: -1000, y: -1000 };
      this.animationId = 0;

      this.init();
      this.animate();

      // Event Listeners
      window.addEventListener("resize", () => this.resize());
      window.addEventListener("mousemove", (e) => this.handleMouseMove(e));
      window.addEventListener("mouseleave", () => this.handleMouseLeave());
    }

    init() {
      this.resize();
    }

    resize() {
      const parent = this.canvas.parentElement;
      if (!parent) return;

      const rect = parent.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      this.width = rect.width;
      this.height = rect.height;

      this.canvas.width = this.width * dpr;
      this.canvas.height = this.height * dpr;
      this.canvas.style.width = `${this.width}px`;
      this.canvas.style.height = `${this.height}px`;

      this.ctx.scale(dpr, dpr);

      this.createParticles();
    }

    createParticles() {
      this.particles = [];
      // Ajuste dinámico: menos partículas en móviles, más en desktop
      const area = this.width * this.height;
      const density = Math.floor(area / 15000); // 1 partícula cada 15000px
      const count = Math.min(Math.max(density, 30), 80); // Min 30, Max 80

      for (let i = 0; i < count; i++) {
        this.particles.push(new Particle(this.width, this.height));
      }
    }

    handleMouseMove(e: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    }

    handleMouseLeave() {
      this.mouse.x = -1000;
      this.mouse.y = -1000;
    }

    drawConnections() {
      // Conexiones entre partículas
      for (let i = 0; i < this.particles.length; i++) {
        for (let j = i + 1; j < this.particles.length; j++) {
          const dx = this.particles[i].x - this.particles[j].x;
          const dy = this.particles[i].y - this.particles[j].y;
          const dist = Math.hypot(dx, dy);

          if (dist < CONFIG.connectionRadius) {
            const opacity = 1 - dist / CONFIG.connectionRadius;
            this.ctx.beginPath();
            this.ctx.strokeStyle = CONFIG.baseColor.replace(
              "0.25",
              `${opacity * 0.2}`
            );
            this.ctx.lineWidth = 1;
            this.ctx.moveTo(this.particles[i].x, this.particles[i].y);
            this.ctx.lineTo(this.particles[j].x, this.particles[j].y);
            this.ctx.stroke();
          }
        }
        // Conexiones con el mouse (Efecto "Inteligente")
        const dxMouse = this.particles[i].x - this.mouse.x;
        const dyMouse = this.particles[i].y - this.mouse.y;
        const distMouse = Math.hypot(dxMouse, dyMouse);

        if (distMouse < CONFIG.mouseRadius) {
          const opacity = 1 - distMouse / CONFIG.mouseRadius;
          this.ctx.beginPath();
          // Aquí usamos el color de acento (cyan/azul)
          this.ctx.strokeStyle = CONFIG.accentColor.replace(
            "0.6",
            `${opacity}`
          );
          this.ctx.lineWidth = 1.5; // Un poco más gruesa
          this.ctx.moveTo(this.particles[i].x, this.particles[i].y);
          this.ctx.lineTo(this.mouse.x, this.mouse.y);
          this.ctx.stroke();

          // Pequeña atracción magnética
          this.particles[i].x -= dxMouse * 0.03;
          this.particles[i].y -= dyMouse * 0.03;
        }
      }
    }

    animate() {
      this.ctx.clearRect(0, 0, this.width, this.height);

      this.particles.forEach((p) => {
        p.update(this.width, this.height);
        p.draw(this.ctx);
      });

      this.drawConnections();
      this.animationId = requestAnimationFrame(() => this.animate());
    }
  }

  class Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;

    constructor(w: number, h: number) {
      this.x = Math.random() * w;
      this.y = Math.random() * h;
      this.vx = (Math.random() - 0.5) * CONFIG.speed;
      this.vy = (Math.random() - 0.5) * CONFIG.speed;
      this.size = Math.random() * 2 + 1;
    }

    update(w: number, h: number) {
      this.x += this.vx;
      this.y += this.vy;

      // Rebote en bordes
      if (this.x < 0 || this.x > w) this.vx *= -1;
      if (this.y < 0 || this.y > h) this.vy *= -1;
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fillStyle = CONFIG.baseColor;
      ctx.fill();
    }
  }

  // Iniciar cuando el DOM esté listo
  document.addEventListener(
    "astro:page-load",
    () => {
      // Soporte para View Transitions de Astro
      new NeuralNetwork();
    },
    { once: true }
  );

  // Fallback por si no usas View Transitions
  if (!document.getElementById("neural-canvas")?.getAttribute("data-loaded")) {
    new NeuralNetwork();
    document
      .getElementById("neural-canvas")
      ?.setAttribute("data-loaded", "true");
  }
</script>
